# Bgp At Doors of Autonomous Systems is Simple ( BADASS )

## Introduction

The purpose of this project is to expand on the knowledge you have gained through NetPractice. You will have to simulate a network and configure it using GNS3 with docker
images .
BGP EVPN is based on BGP (RFC 4271) and its extensions MP-BGP (RFC4760).
BGP is the routing protocol that drives the Internet. Through MP-BGP extensions, it
can be used to carry reachability information (NLRI) for various protocols (IPv4, IPv6,
L3 VPN and in this case, EVPN). EVPN is a special family for publishing information
about MAC addresses and the end devices that access them..

# General guidelines
- The whole project has to be done in a virtual machine.
- This project involves using and installing docker as well as GNS3.
- You have to put all the configuration files of your project in folders located at the
root of your repository (go to Submission and peer-evaluation for more information).
The folders of the mandatory part will be named: P1, P2 and P3.

# Mandatory part
This project will consist of setting up several environments under specific rules.
It is divided into three parts you have to do in the following order:
- Part 1: GNS3 configuration with Docker.
- Part 2: Discovering a VXLAN.
- Part 3: Discovering BGP with EVPN.

## IV.1 Part 1: GNS3 configuration with Docker
For this first part you will have to configure GNS3. It is thus necessary to install and
configure GNS3 as well as docker in your virtual machine.
Now that everything works you need to use two docker images that you have to make.
A first image with a system of your choice containing at least busybox or an equivalent
solution.
A second image using a system of your choice with the following constraints:
- A software that manages packet routing (zebra or quagga)..
- The service BGPD active and configured.
- The service OSPFD active and configured.
- An IS-IS routing engine service.
- Busybox or an equivalent.

You must use these two docker images in GNS3 and realize this small diagram. You
need to have both machines working. We must be able to connect to them by GNS3.
You must render this project in a P1 folder at the root of your git repository. You
should also add the configuration files with comments to explain the set up of each equipment.

## IV.2 Part 2: Discovering a VXLAN
You now have a functional basis to start setting up your first VXLAN (RFC 7348) network.
First in static then in dynamic multicast. Here is the topology of your first VXLAN:
You must configure this network using a VXLAN with an ID of 10 as shown in the
examples below. You can use any VXLAN name you like here: vxlan10. You must set up
a bridge here: br0. You must configure your ETHERNET interfaces as you wish. Below is
an example of the expected result when we inspect the traffic between our two machines
in our VXLAN
We are now going to see the same thing using the groups whose goal will be to be
able to make a dynamic multicast.
We can notice that our machines now have a group (here 239.1.1.1 you can modify
this part):
You must render this project in a P2 folder at the root of your git repository. You
should also add the configuration files with comments to explain the set up of each equipment.

## IV.3 Part 3: Discovering BGP with EVPN
Now that you have mastered the basic principle of the VXLAN we will go a little further and
explore the principle of the BGP EVPN (rfc 7432) without using MPLS to simplify things.
The controller will learn the MAC addresses. We will use our VXLAN with ID 10 seen in
the previous part.
As in the second part we start with the topology of the expected network. We are
going to use the principle of the route reflection (=RR). Our leafs (VTEP) will be
configured to have dynamic relations.
This diagram represents a small datacenter.
When there is no host running we can see our VNI (10 here) as well as our preconfigured routes (type 3). No route type 2 seems to exist and it is quite normal.
A machine host_wil-1 is now functional. We can notice that without assigning an
IP address our VTEP (wil_2) automatically discovers the MAC address of the functional
machines.
We can also see the automatic creation of a route type 2:
In the same way, when we look at a second VTEP(_wil-4), we can notice the creation
of a new route type 2 generated by our RR:
We repeat the operation with a second machine (host_wil-3). We can notice the
second route set up by type 2. There is no assignment of IP address:
For our verification a simple ping allows us to see that we can access all the machines
through our RR using the VTEPs. We can see the VXLAN configured to 10 as well as our
packets ICMP. We also see packets OSPF configured:
You must render this project in a P3 folder at the root of your git repository. You
should also add the configuration files with comments to explain the set up of each equipment.